<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>99 Nights - Forest Map</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: #000; pointer-events: none; z-index: 10; }
        #lock-indicator { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-weight: bold; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px;
        }
    </style>
</head>
<body>

<div id="ui">
    <div style="font-size: 24px; font-weight: bold;">üå≤ –õ–ï–° –ò –ö–û–°–¢–ï–†</div>
    <div style="font-size: 14px;">W,A,S,D - –•–æ–¥–∏—Ç—å | CTRL - –û–±–∑–æ—Ä</div>
</div>
<div id="lock-indicator">SHIFT LOCK: OFF (Press CTRL)</div>

<script type="module">
    // –ü—Ä—è–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è importmap –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OBJLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js';
    import { MTLLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/MTLLoader.js';

    // --- –°–¶–ï–ù–ê ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- –°–í–ï–¢ ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    scene.add(sunLight);

    // --- –ó–ê–ì–†–£–ó–ö–ê –ú–û–î–ï–õ–ï–ô ---
    const objLoader = new OBJLoader();
    const mtlLoader = new MTLLoader();

    function loadModel(path, name, pos, scale = 1) {
        mtlLoader.setPath(path);
        mtlLoader.load(name + '.mtl', (mtl) => {
            mtl.preload();
            objLoader.setMaterials(mtl);
            objLoader.setPath(path);
            objLoader.load(name + '.obj', (obj) => {
                obj.position.copy(pos);
                obj.scale.setScalar(scale);
                obj.rotation.y = Math.random() * Math.PI * 2;
                obj.traverse(n => { if(n.isMesh) { n.castShadow = true; n.receiveShadow = true; }});
                scene.add(obj);
            }, undefined, (err) => console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ OBJ:", name));
        }, undefined, (err) => console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ MTL:", name));
    }

    // –†–ê–°–°–¢–ê–ù–û–í–ö–ê –ú–û–î–ï–õ–ï–ô
    // 1. –ö–æ—Å—Ç–µ—Ä –≤ —Ü–µ–Ω—Ç—Ä–µ
    loadModel('models/models_game/', 'bonfire', new THREE.Vector3(0, 0, 0), 1.2);
    
    // 2. –õ–µ—Å –≤–æ–∫—Ä—É–≥ (30 —Å–ª—É—á–∞–π–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤)
    for(let i = 0; i < 30; i++) {
        const x = (Math.random() - 0.5) * 120;
        const z = (Math.random() - 0.5) * 120;
        // –ù–µ —Å—Ç–∞–≤–∏–º –¥–µ—Ä–µ–≤—å—è –≤ —Ä–∞–¥–∏—É—Å–µ 10 –º–µ—Ç—Ä–æ–≤ –æ—Ç –∫–æ—Å—Ç—Ä–∞
        if (Math.sqrt(x*x + z*z) > 10) {
            const type = Math.random() > 0.3 ? 'tree' : 'big_tree';
            loadModel('models/models_game/', type, new THREE.Vector3(x, 0, z), 1.5 + Math.random() * 2);
        }
    }

    // 3. –°—Ç–∞—Ä—ã–µ –º–æ–¥–µ–ª–∏ –¥–ª—è —Ç–µ—Å—Ç–∞
    loadModel('models/models_game/', 'craft', new THREE.Vector3(5, 0, 5), 1.2);
    loadModel('models/models_animals/', 'wolf', new THREE.Vector3(-10, 0, -10), 1.5);

    // --- –ü–û–õ ---
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(500, 500),
        new THREE.MeshStandardMaterial({ color: 0x2d4c1e })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- –ü–ï–†–°–û–ù–ê–ñ (–ò–ì–†–û–ö) ---
    const player = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), new THREE.MeshStandardMaterial({color: 0x333333}));
    body.position.y = 1; // –í—ã—Å–æ—Ç–∞ —Ç–µ–ª–∞
    player.add(body);
    scene.add(player);
    player.position.set(0, 0, 8); // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è —á—É—Ç—å –¥–∞–ª—å—à–µ –æ—Ç –∫–æ—Å—Ç—Ä–∞

    // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò –ö–ê–ú–ï–†–ê ---
    let isLocked = false, yaw = 0, pitch = 0;
    const keys = {};

    document.addEventListener('keydown', e => {
        keys[e.code] = true;
        if(e.code === 'ControlLeft' || e.code === 'ControlRight') {
            isLocked = !isLocked;
            document.getElementById('lock-indicator').innerText = `SHIFT LOCK: ${isLocked ? 'ON' : 'OFF'}`;
            if(isLocked) document.body.requestPointerLock(); else document.exitPointerLock();
        }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);

    document.addEventListener('mousemove', e => {
        if(isLocked) {
            yaw -= e.movementX * 0.003;
            pitch = Math.max(-1.5, Math.min(1.5, pitch - e.movementY * 0.003));
        }
    });

    // --- –¶–ò–ö–õ –ê–ù–ò–ú–ê–¶–ò–ò ---
    function animate() {
        requestAnimationFrame(animate);
        
        const move = new THREE.Vector3();
        if(keys['KeyW']) move.z -= 1;
        if(keys['KeyS']) move.z += 1;
        if(keys['KeyA']) move.x -= 1;
        if(keys['KeyD']) move.x += 1;

        if(move.length() > 0) {
            move.normalize().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            player.position.add(move.multiplyScalar(0.2));
            player.rotation.y = yaw + Math.PI; // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∏–≥—Ä–æ–∫–∞ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –≤–∑–≥–ª—è–¥–∞
        }

        // –ö–∞–º–µ—Ä–∞ —Å–ª–µ–¥—É–µ—Ç –∑–∞ –∏–≥—Ä–æ–∫–æ–º
        const camOffset = new THREE.Vector3(
            Math.sin(yaw) * Math.cos(pitch) * 12,
            Math.sin(pitch) * 12 + 4,
            Math.cos(yaw) * Math.cos(pitch) * 12
        );
        camera.position.lerp(player.position.clone().add(camOffset), 0.1);
        camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 1.5, 0)));

        renderer.render(scene, camera);
    }
    animate();

    // –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>

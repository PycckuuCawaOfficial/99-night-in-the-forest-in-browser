<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>99 Nights - Model Test Site</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; pointer-events: none; }
        #lock-indicator { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #ffcc00; font-weight: bold; background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
        }
    </style>
</head>
<body>

<div id="ui">
    <div style="font-size: 24px; color: #ffcc00;">üõ†Ô∏è –¢–ï–°–¢ –ú–û–î–ï–õ–ï–ô</div>
    <div style="font-size: 14px; opacity: 0.7;">W,A,S,D - –•–æ–¥–∏—Ç—å | CTRL - –û–±–∑–æ—Ä</div>
</div>
<div id="lock-indicator">SHIFT LOCK: OFF</div>

<script type="importmap">
    { 
        "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        } 
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

    // --- –°–¶–ï–ù–ê ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.FogExp2(0x050510, 0.03);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- –û–°–í–ï–©–ï–ù–ò–ï ---
    // 1. –ú—è–≥–∫–∏–π —Å–≤–µ—Ç –Ω–µ–±–∞ (—Å–≤–µ—Ä—Ö—É –≥–æ–ª—É–±–æ–≤–∞—Ç—ã–π, —Å–Ω–∏–∑—É –∫–æ—Ä–∏—á–Ω–µ–≤–∞—Ç—ã–π)
    const hemiLight = new THREE.HemisphereLight(0x4444ff, 0x221100, 0.5);
    scene.add(hemiLight);

    // 2. –õ—É–Ω–Ω—ã–π —Å–≤–µ—Ç (—Å–æ–∑–¥–∞–µ—Ç —Ç–µ–Ω–∏)
    const moonLight = new THREE.DirectionalLight(0xccccff, 0.4);
    moonLight.position.set(50, 100, 50);
    moonLight.castShadow = true;
    scene.add(moonLight);

    // --- –ü–ï–†–°–û–ù–ê–ñ (BACON HAIR) ---
    const player = new THREE.Group();
    const mat = (c) => new THREE.MeshStandardMaterial({color: c});
    
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), mat(0x111111));
    body.position.y = 1;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat(0xeeeeee));
    head.position.y = 1.6;
    const hair = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.1, 0.45), mat(0x331100));
    hair.position.y = 1.85;
    
    player.add(body, head, hair);
    scene.add(player);

    // --- –ó–ê–ì–†–£–ó–ö–ê –ú–û–î–ï–õ–ï–ô ---
    const objLoader = new OBJLoader();
    const mtlLoader = new MTLLoader();

    function loadModel(path, name, pos, scale = 1, parent = scene) {
        mtlLoader.setPath(path);
        mtlLoader.load(name + '.mtl', (mtl) => {
            mtl.preload();
            objLoader.setMaterials(mtl);
            objLoader.setPath(path);
            objLoader.load(name + '.obj', (obj) => {
                obj.position.copy(pos);
                obj.scale.setScalar(scale);
                obj.traverse(n => { if(n.isMesh) n.castShadow = true; n.receiveShadow = true; });
                parent.add(obj);
                console.log(`‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω: ${name}`);
            }, undefined, e => console.error(`–û—à–∏–±–∫–∞ OBJ ${name}`, e));
        }, undefined, e => console.error(`–û—à–∏–±–∫–∞ MTL ${name}`, e));
    }

    // –†–ê–°–°–¢–ê–í–õ–Ø–ï–ú –ú–û–î–ï–õ–ò –î–õ–Ø –¢–ï–°–¢–ê
    // 1. –í–µ—Ä—Å—Ç–∞–∫ (Crafting Table) - —Å–ø—Ä–∞–≤–∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
    loadModel('models/models_game/', 'craft', new THREE.Vector3(5, 0, 5), 1.5);
    
    // 2. –ú–µ—à–æ–∫ (Old Sack) - —Å–ª–µ–≤–∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
    loadModel('models/item/', 'old_sack', new THREE.Vector3(-5, 0, 5), 1.2);
    
    // 3. –í–æ–ª–∫ - —á—É—Ç—å –¥–∞–ª—å—à–µ
    loadModel('models/models_animals/', 'wolf', new THREE.Vector3(0, 0, 10), 1.5);

    // 4. –ï—â–µ –æ–¥–∏–Ω –º–µ—à–æ–∫ –Ω–∞ —Å–ø–∏–Ω—É –∏–≥—Ä–æ–∫—É
    loadModel('models/item/', 'old_sack', new THREE.Vector3(0, 0.8, -0.2), 0.5, player);

    // --- –ü–û–õ ---
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ color: 0x112211 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï ---
    let isLocked = false, yaw = 0, pitch = 0;
    const keys = {};

    document.addEventListener('keydown', e => {
        keys[e.code] = true;
        if(e.code === 'ControlLeft') {
            isLocked = !isLocked;
            document.getElementById('lock-indicator').innerText = `SHIFT LOCK: ${isLocked ? 'ON' : 'OFF'}`;
            if(isLocked) document.body.requestPointerLock(); else document.exitPointerLock();
        }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => {
        if(isLocked) {
            yaw -= e.movementX * 0.003;
            pitch = Math.max(-1.5, Math.min(1.5, pitch - e.movementY * 0.003));
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        
        const move = new THREE.Vector3();
        if(keys['KeyW']) move.z -= 1; if(keys['KeyS']) move.z += 1;
        if(keys['KeyA']) move.x -= 1; if(keys['KeyD']) move.x += 1;

        if(move.length() > 0) {
            move.normalize().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            player.position.add(move.multiplyScalar(0.15));
            player.rotation.y = yaw + Math.PI;
        }

        const camOffset = new THREE.Vector3(
            Math.sin(yaw) * Math.cos(pitch) * 10,
            Math.sin(pitch) * 10 + 3,
            Math.cos(yaw) * Math.cos(pitch) * 10
        );
        camera.position.lerp(player.position.clone().add(camOffset), 0.1);
        camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 1, 0)));

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
